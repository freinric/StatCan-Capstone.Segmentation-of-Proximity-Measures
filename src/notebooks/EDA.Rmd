---
title: "EDA draft"
author: "Ricky Heinrich & Team"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, cache = T, message = F, warning = F, fig.height=5, fig.width=6)
library(dplyr)
library(factoextra)
library(ggplot2)
library(tidyverse)
library(gridExtra)
```

## Outline
- Overall summary
-- how many variables, how many missing values

- Exploring missing values
-- logistic regression with added variables (master dataset)

- Exploring data distributions
-- histograms (actual numbers)
-- kernel densities (smooth)




# Overall Summary
```{r message = F, warning = F}
#importing data and changing '..' and 'F' to Nas
pmd_na <- readr::read_csv("../../data/pmd-en.csv", na = c('..', 'F'))
# dim(pmd_na)
```
There are 489 676 rows in this data and 41 columns, meaning that 489 676 dissemination blocks are included. The 41 columns include information about the dissemination blocks themselves such as ID, population, and coordinates, as well as information about other census boundaries like dissemination areas, census areas, and provinces. Each of the 10 amenities have two columns associated with it: one a binary indicator to track whether the amenity is present in the DB itself, and the other the calculated proximity measure. Finally there are three indicators: transit_na, amenity_dense, and suppressed.

The DBs cover all of Canada: those included in our dataset are not exhaustive, but still, many have populations of zero. The province codes correspond to each province as follows:
AB: 48
BC: 59
MN: 46
NB: 13
NL: 10
NWT: 61
NC: 12
NV: 62
ON: 35
PEI: 11
QB: 24
SK: 47
YK: 60

It could be reasonable to expect that if the population of a DB is 0, then the proximity measure are also near 0: it is intuitive that for the most part, amenities are further away from areas with no populations. It is thus reasonable to explore the cases where the population is zero, to see its prevalence, and deduce how it may affect the values of proximity measures. We see that Saskatchewan has the most DBs included with a population of zero, followed by Ontario, Quebec, and Alberta. 

```{r}
# how many DB have population of 0
#table(filter(pmd_na, pmd_na$DBPOP == 0)$PRNAME)

pmd_na %>% filter(pmd_na$DBPOP == 0) %>% ggplot(aes(factor(PRUID))) + geom_bar() + labs(title = "How many DBs with population zero by province")
```

Taking the proportions however, we see that over 50% of Yukon and NWT's DBs have a population of 0, and Saskatchewan has over 40%. Ontario has the lowest at around 15%, followed by Quebec at around 18%.

```{r}
# should get proportions
data.frame(table(filter(pmd_na, pmd_na$DBPOP == 0)$PRUID)/table(pmd_na$PRUID)) %>% ggplot(aes(factor(Var1), Freq)) + geom_col() + labs(title = "Proportion of population zero by province")
```

We see that Ontario and Quebec have the most DBs, and the territories have the least.

```{r}
# how many DBs by province
ggplot(pmd_na, aes(factor(PRUID))) + geom_bar() + labs(title = "How many DBs by province")
```

```{r}
# when population is 0, what is the average value of proximity measure

```


We see that Quebec has the most DBs with a population NA, followed by Ontario, Alberta, and BC. The CSDTYPE of the DB's whose population information is NA are IRI – Indian reserve and S-É – Indian settlement. 

```{r}
pmd_na %>% filter(is.na(pmd_na$DBPOP)) %>% ggplot(aes(factor(PRUID))) + geom_bar() + labs(title = "How many DBs with population NA by province")
```
```{r}
table(filter(pmd_na, is.na(DBPOP))$CSDTYPE)
```


In the summary of the dataset, we see that there are many missing values. We see that the library proximity indicator contains the most missing values, at around 77%, followed by the proximity measures for grocery and secondary education. Only two out of the ten amenities have proximity measures missing proportion under 50%: health and employment. 

```{r}
# getting proportions of nas
na_prop <- function(x) {sum(is.na(x))/length(x)*100}
sort(apply(pmd_na, 2, na_prop), decreasing = T)
```

We can see the proportion of missing values for each amenity by province:

```{r}
# Getting infos from data 
amen_cols <- names(select(pmd_na, starts_with("prox"))) # columns names of proximity measures
num_amen_cols <- grep("prox", colnames(pmd_na)) # column numbers of proximity measures
prov_code <- c(48,59,46,13,10,61,12,62,35,11,24,47,60) # province codes
prov_name <- c("AB", "BC", "MN", "NB","NL", "NT", "NC", "NU","ON", "PEI", "QB","SK","YK" ) # province abbreviations


#initialize a matrix and empty list
mat_missing = matrix(data=NA, ncol=length(num_amen_cols), nrow=length(prov_code))
amt_rows <- c()

# Making a matrix of amenities x provinces, percentage missing values
for (i in 1:length(prov_code)){
  # get the number of rows for each province
  amt_rows[i] <- nrow(filter(pmd_na, pmd_na$PRUID == prov_code[i]))
  for (j in 1:length(num_amen_cols)){
    # for every province, iterate through every amenity and get percentage missing
    amt_miss <- nrow(filter(pmd_na, is.na(pmd_na[,num_amen_cols[j]]) & pmd_na$PRUID == prov_code[i]))
    mat_missing[i,j] <- amt_miss/amt_rows[i]
  }
}

# build dataframe, rename columns and rows
df_perc_missing <- mat_missing %>% data.frame() %>% setNames(amen_cols)
rownames(df_perc_missing) <- prov_name

df_perc_missing <- cbind(prov_name, df_perc_missing)

#df_perc_missing
```
```{r fig.height=10, fig.width=12}
# flattening so can facet
df_perc_missing %>% pivot_longer(all_of(amen_cols)) %>%
  ggplot(aes(y = value, x = prov_name, fill = prov_name)) + 
    geom_col() + 
    facet_wrap(~name, ncol = 2) + labs(title = "Missing values for each province by amenity")
```

We see that overall, employment has the lowest rates of missing values, but has also more range. Ontario and Quebec seems to have the least missing values for most amenities relative to the other regions, whereas Nunavut usually has the most. It seems like the amount of proximity measure missing for libraries have the most consistency across regions. 

```{r fig.height=10, fig.width=12}
# flattening so can facet
df_perc_missing %>% pivot_longer(all_of(amen_cols)) %>%
  ggplot(aes(y = value, x = name, fill = name)) + 
    geom_col() + 
    facet_wrap(~prov_name, ncol = 2) + labs(title = "Missing values for each amenity by province")
```

Here we see the same information, but flipped so we can compare each amenity for each province. 


For each amenity, we can plot the occurrence of missing values in a DB vs its population, and plot a basic logistics curve.

```{r}
# convert data so NA = 1, other = 0
df_na <- pmd_na

# converting all values to 0 and all na to 1 for amenities cols
df_na[amen_cols][!is.na(df_na[amen_cols])] <- 0
df_na[amen_cols][is.na(df_na[amen_cols])] <- 1
```

```{r fig.height=3, fig.width=3}
# plot logistics curve for amenity and population
# couldn't figure out easy way to get it; for loops weren't working, and facet involves flattening
#par(mfrow = c(2,5))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_emp)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_pharma)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_childcare)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_health)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_grocery)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_educpri)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_educsec)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_lib)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_parks)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
ggplot(df_na, aes(x=DBPOP, y=prox_idx_transit)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))

```

We see that for some amenities, like employment and health, the missing values are concentrated among DBs with small populations. These are the same amenities with less than 50% of values missing. 

Overall it seems like the population of the DB is not the only factor, if at all, affecting whether a proximity measure is missing for that DB.

We can also plot the histograms of missing values vs populations for each amenity, where '1' (blue) is a missing value and '0' (pink) is a value not missing:

```{r fig.height=4, fig.width=6}
# I should really just facet it
par(mfrow = c(5,2))
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_emp)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_pharma)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_childcare)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_health)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_grocery)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_educpri)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_educsec)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_lib)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_parks)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
ggplot(df_na) +
  geom_histogram(aes(x=DBPOP, fill=factor(prox_idx_transit)), bins = 40,
                 colour="grey50", alpha=0.5, position="identity")
```
Overall, there are more DBs with lower populations than larger populations. We see that for some amenities, at smaller populations, there are a lot more missing values. Again, employment and health are the only two where there are always more actual values than missing values at every population bin. 


### Model with other variables to see relationship: need add 'master' df

```{r eval = F}
# basic model with only population
log_mod <- glm(prox_idx_emp~DBPOP, data = df_na)
summary(log_mod)
# diagnostics
plot(log_mod)
```


# Data Distributions
We can take a preliminary look at the distribution of proximity measures for each amenity, to see if there are 'obvious' clusters.

```{r}
# manipulate dataframe to only keep amenities cols
df_man <- subset(pmd_na, select = amen_cols)
# rename cols for easier plot reading
names(df_man) <- sub('prox_idx_', '', names(df_man))
amen_cols <- names(df_man)
# pivot to long to make work with plots
df_long <- pivot_longer(df_man, all_of(amen_cols))
```

In this violin plot, we see that the highest densities of proximity values lie below 0.12 for all amenities. We see that the amenities with the highest distribution density closer to 0 are health, then employment, then transit. Health and employment have the least amount of missing values, and some conclusion could be made out of that. 

```{r fig.height= 4, fig.width=6}
ggplot(df_long, aes(x=name, y = value)) + geom_violin()
```

Next we see the histograms of proximity values for each amenity. This gives us an idea of the counts for each bin of values. We see that libraries have the least amount of proximity values that are near 0, but we saw above that they also had the greatest amount of missing values.

```{r fig.height=10, fig.width=6}
# histograms
ggplot(df_long, aes(value)) + 
    geom_histogram(bins = 50) + 
    facet_wrap(~name, scales = 'free_y', ncol = 2)
```


Next we see the kernel densities of proximity measures for each amenity. We see that most curves appear smooth, but some like for primary education, secondary education, and library, have 'bumps', which could indicate clusters. Overall, the naked eye is not able to perceive robust clusters, but we will explore if clustering algorithms will.

```{r fig.height=10, fig.width=6}
# kernel densities
ggplot(df_long, aes(value)) + 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 2)
```

- NA values by amenity by province ?
- what happens if I remove all the DBs that don't have population; does that change the values?
- what's the average proximity value if population is 0
- what are the case where there are no proximity measures at all
- what DBs are in the master dataset and not in original: population reason? remote reason? B/c different years have diff DBs amounts
- how many rows where all proximity measures are 0
- assumption: if proximity measure missing values are random for each amenity, then we can randomly inpute it
- are NA values corelated with CSD type

- do we care if population 
- population 

- plot the points for proximities b/w 0.2-1 (cut up granular)
- zoom in: violin plot

Ways to cut data:
- remove all population 0
- remove all NAs 0 for all amenities
- 

## What happens if we remove population = 0?
```{r}
# keeping only vals not 0
pop_0 <- filter(pmd_na, pmd_na$DBPOP !=0)
names(pop_0) <- sub('prox_idx_', '', names(pop_0))
# manipulate dataframe to only keep amenities cols
df_man_pop <- subset(pop_0, select = amen_cols)

# pivot to long to make work with plots
df_long_pop <- pivot_longer(df_man_pop, all_of(amen_cols))


# if only keep population ==0
pop_only0 <- filter(pmd_na, pmd_na$DBPOP ==0)
names(pop_only0) <- sub('prox_idx_', '', names(pop_only0))
# manipulate dataframe to only keep amenities cols
df_man_pop_only <- subset(pop_only0, select = amen_cols)

# pivot to long to make work with plots
df_long_pop_only <- pivot_longer(df_man_pop_only, all_of(amen_cols))
```

```{r fig.height= 4, fig.width=6}
ggplot(df_long_pop, aes(x=name, y = value)) + geom_violin()
```

We cannot tell visually if the distributions are the same or not, as they look like they overlap.
```{r fig.height=10, fig.width=6}
# add row indicating what data type
which_df <- rep("all", nrow(df_long))
df_long <- cbind(df_long, which_df)
which_df <- rep("red", nrow(df_long_pop))
df_long_pop <- cbind(df_long_pop, which_df)
which_df <- rep("pop0", nrow(df_long_pop_only))
df_long_pop_only <- cbind(df_long_pop_only, which_df)

# merge df together
df_long_both <- rbind(df_long, df_long_pop)
df_long_red <- rbind(df_long_pop, df_long_pop_only)

# kernel densities
ggplot(df_long_both, aes(value, fill = which_df)) + 
    geom_density(alpha = .75) + 
    facet_wrap(~name, scales = 'free_y', ncol = 2)

```


For each of the columns:
```{r}
amen_pval <-c()
n = 0
for (amen in amen_cols){
  n = n+1
  amen_pval[n]<- ks.test(filter(df_long, df_long$name == amen)$value, filter(df_long_pop, df_long_pop$name == amen)$value)[["p.value"]]
}

amen_pvaldf <- cbind(amen_cols, round(amen_pval,3))
amen_pvaldf
```
The null hypothesis is that the two samples come from the same distribution. From this table, we see that for most amenities, the p-values are very small, thus leading us to conclude that we have sufficient evidence to say that the full dataset and the reduced dataset don't come from the same distribution. These values are rounded to 3 decimal places.

```{r}
amen_pval <-c()
n = 0
for (amen in amen_cols){
  n = n+1
  amen_pval[n]<- ks.test(filter(df_long_pop_only, df_long_pop_only$name == amen)$value, filter(df_long_pop, df_long_pop$name == amen)$value)[["p.value"]]
}

amen_pvaldf_red <- cbind(amen_cols, round(amen_pval,4))
amen_pvaldf_red
```
We see that for all amenities, the distribution of the dataset when the population = 0 is not the same as the distribution of the remainder of the dataset. These values are rounded to 4 decimal places.

But in what ways do they differ?

Here we are comparing the histogram for both of these population subsets.
```{r fig.height=10, fig.width=6}
# histograms
ggplot(df_long_red, aes(value, fill = which_df)) + 
    geom_histogram(bins = 50, alpha = .5) + 
    facet_wrap(~name, scales = 'free_y', ncol = 2)
```

```{r}
cbind(table(df_long_red$which_df), table(df_long_red$which_df))
```

From this following table, we see that 72% of the proximity measure values where population = 0 are NA, compared to 50% of those where population !=0. 
```{r}
table(df_long_red$which_df,is.na(df_long_red$value))/cbind(table(df_long_red$which_df), table(df_long_red$which_df))
```
```{r}
table(df_long_red$which_df,is.na(df_long_red$value))
```


I'm confused by this following plot, b/c there should be in total more blue than pink, but it looks like for every bin there is more pink then blue ...

```{r fig.height=10, fig.width=6}
# histograms
ggplot(df_long_red, aes(value, fill = which_df)) + 
    geom_histogram(bins = 50, alpha = .5) + 
    facet_wrap(~name, scales = 'free_y', ncol = 2) +xlim(0.25,1)
```


```{r}
ggplot(pmd_na, aes(DBPOP)) + 
    geom_density()
```
```{r}

```

