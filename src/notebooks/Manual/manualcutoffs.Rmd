---
title: "Manual cutoffs"
author: "Ricky Heinrich"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    extra_dependencies: ["float"]
header-includes:
  \usepackage{placeins}
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = F,  cache = T, message = F, warning = F, fig.height=4, fig.width=6)
# remove float formatting
knitr::opts_chunk$set(echo = F,  cache = T, message = F, warning = F, fig.pos = "H", out.extra = "", fig.align = 'center', fig.height=4, fig.width=6)
library(dplyr)
library(factoextra)
library(ggplot2)
library(tidyverse)
library(gridExtra)
```

```{r}
load('../../../data/master_pms_df.Rdata')

# Convert selected columns to numeric
master <- master %>%
  mutate(PMS_DBPOP = as.numeric(gsub(",", "", PMS_DBPOP)), # Dissemination block population
         PMS_DAPOP = as.numeric(gsub(",", "", PMS_DAPOP)), # Dissemination area population
         PMS_CSDPOP = as.numeric(gsub(",", "", PMS_CSDPOP)), # Census subdivision population
         PMS_CMAPOP = as.numeric(gsub(",", "", PMS_CMAPOP)), # Census metropolitan area population
         PMS_PRPOP = as.numeric(gsub(",", "", PMS_PRPOP)), # Province or territory population
         PMS_prox_idx_emp = as.numeric(PMS_prox_idx_emp),
         PMS_prox_idx_pharma = as.numeric(PMS_prox_idx_pharma),
         PMS_prox_idx_childcare = as.numeric(PMS_prox_idx_childcare),
         PMS_prox_idx_health = as.numeric(PMS_prox_idx_health),
         PMS_prox_idx_grocery = as.numeric(PMS_prox_idx_grocery),
         PMS_prox_idx_educpri = as.numeric(PMS_prox_idx_educpri),
         PMS_prox_idx_educsec = as.numeric(PMS_prox_idx_educsec),
         PMS_prox_idx_lib = as.numeric(PMS_prox_idx_lib),
         PMS_prox_idx_parks = as.numeric(PMS_prox_idx_parks),
         PMS_prox_idx_transit = as.numeric(PMS_prox_idx_transit),
         DBUID = as.character(DBUID),
         PMS_DAUID = as.character(PMS_DAUID),
         PMS_CSDUID = as.character(PMS_CSDUID),
         PMS_CMAUID = as.character(PMS_CMAUID),
         PMS_CMAPUID = as.character(PMS_CMAPUID),
         PMS_PRUID = as.character(PMS_PRUID),
         PMS_suppressed = as.character(PMS_suppressed),
         PMS_transit_na = as.character(PMS_suppressed))


# Subset columns that start with "prox_idx"
amenities <- colnames(master)[grepl("^PMS_prox_idx", colnames(master))]
# master dataset - contains only proximity columns
master_amenities <- master[, amenities]

# subsampling data 
perc = 3 #percentage of data to subsample
subsample = (nrow(master)/100)*perc 
master_sample = master[sample(nrow(master), subsample),] #random sample
```
\newpage
# Introduction

The Proximity Measures Database contains continuous measures for 10 amenities for a number of DB within a specific threshold. The distribution of these proximity measures is heavily right skewed, and there are for the most part no discernible clusters. The density distribution of each amenity is shown in Figure 1.

```{r fig.height=7, fig.width=7, fig.cap="Distribution of proximity measures by amenity"}
master[,amenities] %>% pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```


When transforming the data, the inherent relationship between data points remain the same, but the new structure may reveal new insights. The most 'famous' transformation available is the log transform. It ["can be used to make highly skewed distributions less skewed"](https://stats.libretexts.org/Bookshelves/Introductory_Statistics/Book%3A_Introductory_Statistics_(Lane)/16%3A_Transformations/16.02%3A_Log_Transformations). It may help "make patterns more visible". A consideration to be aware of is that the log of 0 is -Inf. To account for proximity values of 0 in our dataset, we shift the distribution by +0.0001. This avoids the problem of -Inf whilst maintaining the original distances between all values. The downsides of using a log transformation are [DOWNSIDES]. Figure 2 demonstrates the distribution of the log transformed proximity measures, where all the amenities' distributions were shifted by +0.0001. We can already visually identify more possible clusters. 

In Figure 3, we only shifted the distribution by +0.0001 of the amenities that had a minimum value of 0. Grocery, educpri, educsec, and lib did not have values of 0 in their distribution and such were not shifted. The visual difference of the distributions between when +0.0001 is applied vs when it is not are imperceptible. For simplification in reproducibility, we will just apply the distribution shift to all amenities. 

```{r eval = F}
# number of 0s per amenity: expecting 1 per amenity
apply(master_amenities , 2 , function(x) sum(na.omit(x == 0)) )

# minimum proximity measure for each amenity: expecting 0
apply(master_amenities , 2 , function(x) min(na.omit(x)) )

# number of 1s per amenity: expecting 1 per amenity
apply(master_amenities , 2 , function(x) sum(na.omit(x == 1)) )
```


```{r eval = F, fig.height=10, fig.width=6, fig.cap="LOG TRANSFORMED: Distribution of proximity measures by amenity"}
master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.001)) %>% log() %>%  pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 2) + labs(title = "")
```

```{r fig.height=7, fig.width=7, fig.cap="LOG TRANSFORMED(0.0001): Distribution of proximity measures by amenity"}
master_log <- master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.0001)) %>% log()

master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.0001)) %>% log() %>%  pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```

```{r fig.height=7, fig.width=7, fig.cap="LOG TRANSFORMED(0.0001 in some): Distribution of proximity measures by amenity"}
# amenities w/o 0
# amenities[! amenities %in% c('PMS_prox_idx_grocery','PMS_prox_idx_educpri', 'PMS_prox_idx_educsec','PMS_prox_idx_lib' )]

master_log <- master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.0001)) %>% log()

master[,amenities] %>% mutate(across(all_of(amenities[! amenities %in% c('PMS_prox_idx_grocery','PMS_prox_idx_educpri', 'PMS_prox_idx_educsec','PMS_prox_idx_lib' )]), ~ .x + 0.0001)) %>% log() %>%  pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```

```{r eval = F, fig.height=7, fig.width=7, fig.cap="SAMPLED LOG TRANSFORMED Distribution of proximity measures by amenity"}
master_sample_log <- master_sample

# log transform on PMs in master amenities
for (col in amenities){
  master_sample_log[, col] = log(master_sample[, col]+0.001)
}

master_sample_log[,amenities] %>% pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```

\FloatBarrier
# Segmenting via minima

A segmentation technique is to segment the distribution at select minima of the density distribution. Each minimum in the density curves represents a density sparse region, which may be a 'natural' break in the continuous measures. Figure 4 provides an overview of where maxima and minima are located in the density curves of every amenity. We see that there are a lot of points that are by definition local minima, but are not fully indicative of density sparse regions. We can limit which minima are representative of density sparse regions by only including those who have a threshold difference between themselves and surrounding maxima. We will conduct an indepth analysis of which minima should intuitively represent a cutoff value for each amenity.





```{r eval = F, fig.cap="Location of Minima and Maxima"}
# for childcare for example
d_child <- density(master_log$PMS_prox_idx_childcare, na.rm = T)

# get locations of Mins and Maxes
DeltaY = diff(d_child$y) # difference in y from x to x+1; same sign as derivative

# if product of consecutive values is negative, that means the sign changed
# essentially remove the first obs, remove the last obs, gives series with same size, but shifted by one
# when multiply together, multiplying consecutive values
Turns = which(DeltaY[-1] * DeltaY[-length(DeltaY)] < 0) + 1 # turning points where sign changed

# if turn point is negative, then maximum
# if turn point is positive, then minimum
lst_max <- c()
lst_min <- c()
for (i in Turns){
  
  if (DeltaY[i]<0) {
    lst_max <- append(lst_max, i)
  }
  if (DeltaY[i]>0){
    lst_min <- append(lst_min, i)
  }
}

# plot mins and maxes on density plot
plot(d_child, xlab="", ylab="", main="")
points(d_child$x[lst_max], d_child$y[lst_max], pch=16, col="blue")
points(d_child$x[lst_min], d_child$y[lst_min], pch=16, col="red")
legend(x="topright", legend = c("Minima","Maxima"), col = c("red","blue"), pch = 16)

```

```{r fig.height=7, fig.width=7, fig.cap="Location of minima and maxima"}
# function to get legend as standalone plot
g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
}

## reproduce on all plots ##
dense_plot_list <- list() # initialize plot list
big_list <- list() # initilize list of amenity lists
count <- 0 

for (amen in amenities){
  # make a list for each amenity, add list to list at end
  # in the list for given amenity, will have density list, max vector, min vector
  count <- count+1
  amen_list <- list()
  amen_list[[1]] <- density(master_log[,amen], na.rm = T) # list of densities
  d_amen <-  density(master_log[,amen], na.rm = T)
  
  # get locations of local minima and maxima
  DeltaY <- diff(d_amen$y) 
  Turns <- which(DeltaY[-1] * DeltaY[-length(DeltaY)] < 0) + 1
  
  
  lst_max <- c()
  lst_min <- c()
  for (i in Turns){
    if (DeltaY[i]<0) {
      lst_max <- append(lst_max, i)
    }
    if (DeltaY[i]>0){
      lst_min <- append(lst_min, i)
    }
  }
  amen_list[[2]] <- lst_max
  amen_list[[3]] <- lst_min
  amen_list[[4]] <- amen_list[[1]][["y"]][amen_list[[2]]]-amen_list[[1]][["y"]][amen_list[[3]]] # diff b/w max and following min density values
  
  # preparing df for plot
  df_dense <- data.frame(x = d_amen$x, y= d_amen$y)
  df_max <- data.frame(x = d_amen$x[lst_max], y = d_amen$y[lst_max], type = "max", index = 1:length(lst_max))
  df_min <- data.frame(x = d_amen$x[lst_min], y = d_amen$y[lst_min], type = "min", index = 1:length(lst_min))
  df_minmax <- rbind(df_max, df_min)
  dense_plot_list[[amen]] <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14))
  # add plot to big list
  amen_list[[5]] <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # with points
  amen_list[[6]] <- ggplot(df_dense, aes(x,y))+ geom_line()+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # without points
  amen_list[[7]] <- list(df_minmax)
  
  
  names(amen_list) <- c("density", "maxima", "minima", "maxmindiff", "plot", "nopt", "df_minmax")
  big_list[[count]] <- amen_list # add amenity list to big list
}
names(big_list) <- amenities # rename big list

# set legend: for whichever amen last out of loop, get legend (same for all)
legend_plot <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))
dense_plot_list[[11]] = g_legend(legend_plot)

# layout of plots
layout_mat <- rbind(c(1:3),
                    c(4:6),
                    c(7:9),
                    c(10:11, 11))
do.call(grid.arrange,list(grobs=dense_plot_list, layout_matrix=layout_mat))

# save image
#cutoffs = do.call(grid.arrange,list(grobs=p, layout_matrix=layout_mat))
#ggsave("cutoffs_hdbscan.png", cutoffs, dpi = 400, width=8, height=5)

```




## Employment

The Employment density distribution contains `r length( big_list[["PMS_prox_idx_emp"]][["minima"]])` minima. The following figure illustrates the density distribution with the minima ploted in blue and the maxima in red. Visually, we may not construe the third or the fourth minima as a cutoff value, as the peak in between is fairly small. As well, there are other areas in the curve that seem to plateau, and may be visually decent places for a cutoff value, but are not technically places where a minima is present.

As is, there would be  `r length( big_list[["PMS_prox_idx_emp"]][["maxima"]])` groups, corresponding to  `r length( big_list[["PMS_prox_idx_emp"]][["minima"]])` cutoffs.

```{r fig.cap="Employment density curve with minima and maxima"}
# plot
big_list[["PMS_prox_idx_emp"]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r eval = F, fig.cap="Difference between density value of a maxima-minima pairs, with suggested threshold = 0.01"}
plot(big_list[[1]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.01, lty=2, col = "grey")
```
```{r eval = F}
big_list[[1]][["maxmindiff"]]
```

## Pharmacies

```{r }
# diff b/w first max and first min
first_diff <- big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["maxima"]][1]]-big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["minima"]][1]]

eight_diff <- big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["maxima"]][8]]-big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["minima"]][8]]
```


In the case of Pharmacies, shown in Figure 6, there are many technical minima and maxima in an area that visually seems flat and have overall very low density. There is no doubt that these areas are not indicative specifically of density sparse regions, as the whole area is density sparse. The following plot, Figure 7, shows the difference between the density value of maxima-minima pairs (unidirectional). We see that for Pharmacies, the difference in the first 6 pairs is very small, as we can tell from the previous plot. The difference in density between the first maxima and the first minima, for example, is `r first_diff`, which is very small compared to the 8th (the 2nd visually discernible peak in Figure 6): `r eight_diff`. This may suggest that we should only use as cutoffs the minima that have a threshold difference with the neighbouring maxima. An appropriate threshold for Pharmacies may be a difference of 0.001.

```{r fig.cap="Pharmacies density curve with minima and maxima"}
# plot
big_list[[2]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```



```{r eval = F, fig.cap="Difference between density value of a maxima and minima following it"}
# want make a df with max, min, diff
maxmindf <- as.data.frame(cbind(big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["maxima"]]],big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["minima"]]]))
colnames(maxmindf) <- c('maxima', 'minima')
mutate(maxmindf, diffmaxmin = maxima - minima)
```
```{r fig.cap="Difference between density value of a maxima-minima pairs, with suggested threshold = 0.001"}
plot(big_list[["PMS_prox_idx_pharma"]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

Removing the pairs of where the difference is below the threshold values give us the following plot. We see that in this case, there would be 2 cutoff points giving 3 groups. 

```{r fig.cap="Density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
threshold <- 0.001
big_list[[2]][["df_minmax"]][[1]] <- big_list[[2]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[2]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[2]][["nopt"]] +geom_point(data = filter(big_list[[2]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```



```{r eval = F}
# if the difference is lower than threshold, then that index value should not be plotted for the max nor the min
ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # with points
ggplot(df_dense, aes(x,y))+ geom_line()+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # without points

# add column to df_minmax where it says if above threshold or not, then filter data when including to only have aboves

df_dense <- data.frame(x = d_amen$x, y= d_amen$y)
  df_max <- data.frame(x = d_amen$x[lst_max], y = d_amen$y[lst_max], type = "max")
  df_min <- data.frame(x = d_amen$x[lst_min], y = d_amen$y[lst_min], type = "min")
  df_minmax <- rbind(df_max, df_min)
big_list[["PMS_prox_idx_transit"]][["nopt"]] +geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none")


big_list[["PMS_prox_idx_transit"]][["nopt"]] +geom_point(data = big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]], mapping = aes(x,y, col = type))+ theme(legend.position="none")

# df
big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] # 7 items, 7 maxes
which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001)

# if index 1 is below threshold, then that's index 1 in max list and index 1 in min list


big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]]

# add column to df_minmax

big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]] %>% mutate(threshold = ifelse(index %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1 ))

 ifelse(big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]]  %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1 )


mutate(big_list[["PMS_prox_idx_emp"]][["df_minmax"]][[1]], threshold = ifelse(~ .x %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1) )

ifelse(~ .x %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1)

big_list[["PMS_prox_idx_emp"]][["df_minmax"]][[1]] <- cbind(big_list[["PMS_prox_idx_emp"]][["df_minmax"]][[1]], 1:9)
```
```{r eval = F}
# removing minima that aren't above threshold
# add include row in df
big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]] <- big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1))

# plot w/ filter
big_list[["PMS_prox_idx_transit"]][["nopt"]] +geom_point(data = filter(big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```







## Childcare

## etc

```{r eval=F}

df_dense <- data.frame(x = d_child$x, y= d_child$y)
df_max <- data.frame(x = d_child$x[lst_max], y = d_child$y[lst_max], type = "max")
df_min <- data.frame(x = d_child$x[lst_min], y = d_child$y[lst_min], type = "min")
df_minmax <- rbind(df_max, df_min)
ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ 
    theme(
      #axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=1, size=8), 
      panel.grid.major = element_blank(), 
      panel.grid.minor = element_blank(),
      plot.margin=unit(c(0,0,0.1,0),"cm"),
      plot.title = element_text(size = 10),
      axis.ticks.y = element_blank(),
      axis.text.y = element_blank(),
      axis.text.x = element_blank(), #removes x axis labels
      axis.ticks.x = element_blank() #removes x axis ticks
      )
```




### Extra code
```{r eval = F, fig.height=7, fig.width=7, fig.cap="Location of minima and maxima"}

dense_plot_list <- list() # initialize plot list
big_list <- list() # initilize list of amenity lists
count <- 0 

for (amen in amenities){
  # make a list for each amenity, add list to list at end
  # in the list for given amenity, will have density list, max vector, min vector
  count <- count+1
  amen_list <- list()
  amen_list[[1]] <- density(master_log[,amen], na.rm = T) # list of densities
  d_amen <-  density(master_log[,amen], na.rm = T)
  
  # get locations of local minima and maxima
  DeltaY <- diff(d_amen$y) 
  Turns <- which(DeltaY[-1] * DeltaY[-length(DeltaY)] < 0) + 1
  
  
  lst_max <- c()
  lst_min <- c()
  for (i in Turns){
    if (DeltaY[i]<0) {
      lst_max <- append(lst_max, i)
    }
    if (DeltaY[i]>0){
      lst_min <- append(lst_min, i)
    }
  }
  amen_list[[2]] <- lst_max
  amen_list[[3]] <- lst_min
  amen_list[[4]] <- amen_list[[1]][["y"]][amen_list[[2]]]-amen_list[[1]][["y"]][amen_list[[3]]] # diff b/w max and following min density values
  
  # preparing df for plot
  df_dense <- data.frame(x = d_amen$x, y= d_amen$y)
  df_max <- data.frame(x = d_amen$x[lst_max], y = d_amen$y[lst_max], type = "max")
  df_min <- data.frame(x = d_amen$x[lst_min], y = d_amen$y[lst_min], type = "min")
  df_minmax <- rbind(df_max, df_min)
  dense_plot_list[[amen]] <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14))
  # add plot to big list
  amen_list[[5]] <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # with points
  amen_list[[6]] <- ggplot(df_dense, aes(x,y))+ geom_line()+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # without points
  amen_list[[7]] <- df_minmax
  
  
  names(amen_list) <- c("density", "maxima", "minima", "maxmindiff", "plot", "nopt", "df_minmax")
  big_list[[count]] <- amen_list # add amenity list to big list
}
names(big_list) <- amenities # rename big list

# set legend: for whichever amen last out of loop, get legend (same for all)
legend_plot <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))
dense_plot_list[[11]] = g_legend(legend_plot)

# layout of plots
layout_mat <- rbind(c(1:3),
                    c(4:6),
                    c(7:9),
                    c(10:11, 11))
do.call(grid.arrange,list(grobs=dense_plot_list, layout_matrix=layout_mat))

# save image
#cutoffs = do.call(grid.arrange,list(grobs=p, layout_matrix=layout_mat))
#ggsave("cutoffs_hdbscan.png", cutoffs, dpi = 400, width=8, height=5)

```


```{r eval=F}
# figuring out how to add to big list all at once
big_list[[10]][["density"]][["y"]][big_list[[10]][["maxima"]]]-big_list[[10]][["density"]][["y"]][big_list[[10]][["minima"]]]

amen_list[["density"]][["y"]][amen_list[["maxima"]]]-amen_list[["density"]][["y"]][amen_list[["minima"]]]

big_list[["PMS_prox_idx_transit"]][["maxmindiff"]]
```
