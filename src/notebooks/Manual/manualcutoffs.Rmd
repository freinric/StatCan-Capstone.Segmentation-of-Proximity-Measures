---
title: "Manual cutoffs"
author: "Ricky Heinrich"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    extra_dependencies: ["float"]
header-includes:
  \usepackage{placeins}
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = F,  cache = T, message = F, warning = F, fig.height=4, fig.width=6)
# remove float formatting
knitr::opts_chunk$set(echo = F,  cache = T, message = F, warning = F, fig.pos = "H", out.extra = "", fig.align = 'center', fig.height=3, fig.width=6)
library(dplyr)
library(factoextra)
library(ggplot2)
library(tidyverse)
library(gridExtra)
```

```{r}
load('../../../data/master_pms_df.Rdata')

# Convert selected columns to numeric
master <- master %>%
  mutate(PMS_DBPOP = as.numeric(gsub(",", "", PMS_DBPOP)), # Dissemination block population
         PMS_DAPOP = as.numeric(gsub(",", "", PMS_DAPOP)), # Dissemination area population
         PMS_CSDPOP = as.numeric(gsub(",", "", PMS_CSDPOP)), # Census subdivision population
         PMS_CMAPOP = as.numeric(gsub(",", "", PMS_CMAPOP)), # Census metropolitan area population
         PMS_PRPOP = as.numeric(gsub(",", "", PMS_PRPOP)), # Province or territory population
         PMS_prox_idx_emp = as.numeric(PMS_prox_idx_emp),
         PMS_prox_idx_pharma = as.numeric(PMS_prox_idx_pharma),
         PMS_prox_idx_childcare = as.numeric(PMS_prox_idx_childcare),
         PMS_prox_idx_health = as.numeric(PMS_prox_idx_health),
         PMS_prox_idx_grocery = as.numeric(PMS_prox_idx_grocery),
         PMS_prox_idx_educpri = as.numeric(PMS_prox_idx_educpri),
         PMS_prox_idx_educsec = as.numeric(PMS_prox_idx_educsec),
         PMS_prox_idx_lib = as.numeric(PMS_prox_idx_lib),
         PMS_prox_idx_parks = as.numeric(PMS_prox_idx_parks),
         PMS_prox_idx_transit = as.numeric(PMS_prox_idx_transit),
         DBUID = as.character(DBUID),
         PMS_DAUID = as.character(PMS_DAUID),
         PMS_CSDUID = as.character(PMS_CSDUID),
         PMS_CMAUID = as.character(PMS_CMAUID),
         PMS_CMAPUID = as.character(PMS_CMAPUID),
         PMS_PRUID = as.character(PMS_PRUID),
         PMS_suppressed = as.character(PMS_suppressed),
         PMS_transit_na = as.character(PMS_suppressed))


# Subset columns that start with "prox_idx"
amenities <- colnames(master)[grepl("^PMS_prox_idx", colnames(master))]
# master dataset - contains only proximity columns
master_amenities <- master[, amenities]

# subsampling data 
perc = 3 #percentage of data to subsample
subsample = (nrow(master)/100)*perc 
master_sample = master[sample(nrow(master), subsample),] #random sample
```
\newpage
# Introduction

The Proximity Measures Database contains continuous measures for 10 amenities for a number of DB within a specific threshold. The distribution of these proximity measures is heavily right skewed, and there are for the most part no discernible clusters. The density distribution, with a default bandwidth, of each amenity is shown in Figure 1.

```{r fig.height=7, fig.width=7, fig.cap="Distribution of proximity measures by amenity"}
master[,amenities] %>% pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```


When transforming the data, the inherent relationship between data points remain the same, but the new structure may reveal new insights. The most 'famous' transformation available is the log transform. It ["can be used to make highly skewed distributions less skewed"](https://stats.libretexts.org/Bookshelves/Introductory_Statistics/Book%3A_Introductory_Statistics_(Lane)/16%3A_Transformations/16.02%3A_Log_Transformations). It may help "make patterns more visible". A consideration to be aware of is that the log of 0 is -Inf. To account for proximity values of 0 in our dataset, we shift the distribution by +0.0001. This avoids the problem of -Inf whilst maintaining the original distances between all values. The downsides of using a log transformation are [DOWNSIDES]. Figure 2 demonstrates the distribution of the log transformed proximity measures, where all the amenities' distributions were shifted by +0.0001. We can already visually identify more possible clusters. 

In Figure 3, we only shifted the distribution by +0.0001 of the amenities that had a minimum value of 0. Grocery, educpri, educsec, and lib did not have values of 0 in their distribution and such were not shifted. The visual difference of the distributions between when +0.0001 is applied vs when it is not are imperceptible. For simplification in reproducibility, we will apply the distribution shift to all amenities. 

```{r eval = F}
# number of 0s per amenity: expecting 1 per amenity
apply(master_amenities , 2 , function(x) sum(na.omit(x == 0)) )

# minimum proximity measure for each amenity: expecting 0
apply(master_amenities , 2 , function(x) min(na.omit(x)) )

# number of 1s per amenity: expecting 1 per amenity
apply(master_amenities , 2 , function(x) sum(na.omit(x == 1)) )
```


```{r eval = F, fig.height=10, fig.width=6, fig.cap="LOG TRANSFORMED: Distribution of proximity measures by amenity"}
master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.001)) %>% log() %>%  pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 2) + labs(title = "")
```

```{r fig.height=7, fig.width=7, fig.cap="LOG TRANSFORMED(0.0001): Distribution of proximity measures by amenity"}
master_log <- master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.0001)) %>% log()

master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.0001)) %>% log() %>%  pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```

```{r fig.height=7, fig.width=7, fig.cap="LOG TRANSFORMED(0.0001 in some): Distribution of proximity measures by amenity"}
# amenities w/o 0
# amenities[! amenities %in% c('PMS_prox_idx_grocery','PMS_prox_idx_educpri', 'PMS_prox_idx_educsec','PMS_prox_idx_lib' )]

master_log <- master[,amenities] %>% mutate(across(all_of(amenities), ~ .x + 0.0001)) %>% log()

master[,amenities] %>% mutate(across(all_of(amenities[! amenities %in% c('PMS_prox_idx_grocery','PMS_prox_idx_educpri', 'PMS_prox_idx_educsec','PMS_prox_idx_lib' )]), ~ .x + 0.0001)) %>% log() %>%  pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```

```{r eval = F, fig.height=7, fig.width=7, fig.cap="SAMPLED LOG TRANSFORMED Distribution of proximity measures by amenity"}
master_sample_log <- master_sample

# log transform on PMs in master amenities
for (col in amenities){
  master_sample_log[, col] = log(master_sample[, col]+0.001)
}

master_sample_log[,amenities] %>% pivot_longer(all_of(amenities)) %>%
  ggplot(aes(value))+ 
    geom_density() + 
    facet_wrap(~name, scales = 'free_y', ncol = 3) + labs(title = "")
```

\FloatBarrier
# Segmenting via minima

A segmentation technique is to segment the distribution at select minima of the density distribution. Each minimum in the density curves represents a density sparse region, which may be a 'natural' break in the continuous measures. Figure 4 provides an overview of where maxima and minima are located in the density curves of every amenity. We see that there are a lot of points that are by definition local minima, but are not fully indicative of density sparse regions. We can limit which minima are representative of density sparse regions by only including those who have a threshold difference between themselves and surrounding maxima. We will conduct an indepth analysis of which minima should intuitively represent a cutoff value for each amenity.





```{r eval = F, fig.cap="Location of Minima and Maxima"}
# for childcare for example
d_child <- density(master_log$PMS_prox_idx_childcare, na.rm = T)

# get locations of Mins and Maxes
DeltaY = diff(d_child$y) # difference in y from x to x+1; same sign as derivative

# if product of consecutive values is negative, that means the sign changed
# essentially remove the first obs, remove the last obs, gives series with same size, but shifted by one
# when multiply together, multiplying consecutive values
Turns = which(DeltaY[-1] * DeltaY[-length(DeltaY)] < 0) + 1 # turning points where sign changed

# if turn point is negative, then maximum
# if turn point is positive, then minimum
lst_max <- c()
lst_min <- c()
for (i in Turns){
  
  if (DeltaY[i]<0) {
    lst_max <- append(lst_max, i)
  }
  if (DeltaY[i]>0){
    lst_min <- append(lst_min, i)
  }
}

# plot mins and maxes on density plot
plot(d_child, xlab="", ylab="", main="")
points(d_child$x[lst_max], d_child$y[lst_max], pch=16, col="blue")
points(d_child$x[lst_min], d_child$y[lst_min], pch=16, col="red")
legend(x="topright", legend = c("Minima","Maxima"), col = c("red","blue"), pch = 16)

```

```{r fig.height=7, fig.width=7, fig.cap="Location of minima and maxima"}
# function to get legend as standalone plot
g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
}

## reproduce on all plots ##
dense_plot_list <- list() # initialize plot list
big_list <- list() # initilize list of amenity lists
count <- 0 

for (amen in amenities){
  # make a list for each amenity, add list to list at end
  # in the list for given amenity, will have density list, max vector, min vector
  count <- count+1
  amen_list <- list()
  amen_list[[1]] <- density(master_log[,amen], na.rm = T) # list of densities
  d_amen <-  density(master_log[,amen], na.rm = T)
  
  # get locations of local minima and maxima
  DeltaY <- diff(d_amen$y) 
  Turns <- which(DeltaY[-1] * DeltaY[-length(DeltaY)] < 0) + 1
  
  
  lst_max <- c()
  lst_min <- c()
  for (i in Turns){
    if (DeltaY[i]<0) {
      lst_max <- append(lst_max, i)
    }
    if (DeltaY[i]>0){
      lst_min <- append(lst_min, i)
    }
  }
  amen_list[[2]] <- lst_max
  amen_list[[3]] <- lst_min
  amen_list[[4]] <- amen_list[[1]][["y"]][amen_list[[2]]]-amen_list[[1]][["y"]][amen_list[[3]]] # diff b/w max and following min density values
  
  # preparing df for plot
  df_dense <- data.frame(x = d_amen$x, y= d_amen$y)
  df_max <- data.frame(x = d_amen$x[lst_max], y = d_amen$y[lst_max], type = "max", index = 1:length(lst_max))
  df_min <- data.frame(x = d_amen$x[lst_min], y = d_amen$y[lst_min], type = "min", index = 1:length(lst_min))
  df_minmax <- rbind(df_max, df_min)
  dense_plot_list[[amen]] <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14))
  # add plot to big list
  amen_list[[5]] <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # with points
  amen_list[[6]] <- ggplot(df_dense, aes(x,y))+ geom_line()+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # without points
  amen_list[[7]] <- list(df_minmax)
  
  
  names(amen_list) <- c("density", "maxima", "minima", "maxmindiff", "plot", "nopt", "df_minmax")
  big_list[[count]] <- amen_list # add amenity list to big list
}
names(big_list) <- amenities # rename big list

# set legend: for whichever amen last out of loop, get legend (same for all)
legend_plot <- ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))
dense_plot_list[[11]] = g_legend(legend_plot)

# layout of plots
layout_mat <- rbind(c(1:3),
                    c(4:6),
                    c(7:9),
                    c(10:11, 11))
do.call(grid.arrange,list(grobs=dense_plot_list, layout_matrix=layout_mat))

# save image
#cutoffs = do.call(grid.arrange,list(grobs=p, layout_matrix=layout_mat))
#ggsave("cutoffs_hdbscan.png", cutoffs, dpi = 400, width=8, height=5)

```




## Employment

The Employment density distribution contains `r length( big_list[["PMS_prox_idx_emp"]][["minima"]])` minima. The following figure illustrates the density distribution with the minima ploted in blue and the maxima in red. Visually, we may not construe the third or the fourth minima as a cutoff value, as the peak in between is fairly small. As well, there are other areas in the curve that seem to plateau, and may be visually decent places for a cutoff value, but are not technically places where a minima is present.

As is, there would be  `r length( big_list[["PMS_prox_idx_emp"]][["maxima"]])` groups, corresponding to  `r length( big_list[["PMS_prox_idx_emp"]][["minima"]])` cutoffs.

```{r fig.cap="Employment density curve with minima and maxima"}
# plot
big_list[["PMS_prox_idx_emp"]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r eval = F, fig.cap="Difference between density value of a maxima-minima pairs, with suggested threshold = 0.01"}
plot(big_list[[1]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.01, lty=2, col = "grey")
```
```{r eval = F}
big_list[[1]][["maxmindiff"]]
```

## Pharmacies

```{r}
# diff b/w first max and first min
first_diff <- big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["maxima"]][1]]-big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["minima"]][1]]

eight_diff <- big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["maxima"]][8]]-big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["minima"]][8]]
```


In the case of Pharmacies, shown in Figure 6, there are many technical minima and maxima in an area that visually seems flat and have overall very low density. There is no doubt that these areas are not indicative specifically of density sparse regions, as the whole area is density sparse. The following plot, Figure 7, shows the difference between the density value of maxima-minima pairs (unidirectional). We see that for Pharmacies, the difference in the first 6 pairs is very small, as we can tell from the previous plot. The difference in density between the first maxima and the first minima, for example, is `r first_diff`, which is very small compared to the 8th (the 2nd visually discernible peak in Figure 6): `r eight_diff`. This may suggest that we should only use as cutoffs the minima that have a threshold difference with the neighbouring maxima. An appropriate threshold for Pharmacies may be a difference of 0.001.

```{r fig.cap="Pharmacies density curve with minima and maxima"}
# plot
big_list[[2]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```



```{r eval = F, fig.cap="Difference between density value of a maxima and minima following it"}
# want make a df with max, min, diff
maxmindf <- as.data.frame(cbind(big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["maxima"]]],big_list[["PMS_prox_idx_pharma"]][["density"]][["y"]][big_list[["PMS_prox_idx_pharma"]][["minima"]]]))
colnames(maxmindf) <- c('maxima', 'minima')
mutate(maxmindf, diffmaxmin = maxima - minima)
```
```{r fig.cap="Difference between density value of a maxima-minima pairs, with suggested threshold = 0.001"}
plot(big_list[["PMS_prox_idx_pharma"]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

Removing the pairs of where the difference is below the threshold values give us the following plot. We see that in this case, there would be 2 cutoff points giving 3 groups. 

```{r fig.cap="Density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
threshold <- 0.001
big_list[[2]][["df_minmax"]][[1]] <- big_list[[2]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[2]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[2]][["nopt"]] +geom_point(data = filter(big_list[[2]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```



```{r eval = F}
# if the difference is lower than threshold, then that index value should not be plotted for the max nor the min
ggplot(df_dense, aes(x,y))+ geom_line()+geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # with points
ggplot(df_dense, aes(x,y))+ geom_line()+ theme(legend.position="none") +
    ggtitle(str_sub(amen, 14)) # without points

# add column to df_minmax where it says if above threshold or not, then filter data when including to only have aboves

df_dense <- data.frame(x = d_amen$x, y= d_amen$y)
  df_max <- data.frame(x = d_amen$x[lst_max], y = d_amen$y[lst_max], type = "max")
  df_min <- data.frame(x = d_amen$x[lst_min], y = d_amen$y[lst_min], type = "min")
  df_minmax <- rbind(df_max, df_min)
big_list[["PMS_prox_idx_transit"]][["nopt"]] +geom_point(data = df_minmax, mapping = aes(x,y, col = type))+ theme(legend.position="none")


big_list[["PMS_prox_idx_transit"]][["nopt"]] +geom_point(data = big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]], mapping = aes(x,y, col = type))+ theme(legend.position="none")

# df
big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] # 7 items, 7 maxes
which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001)

# if index 1 is below threshold, then that's index 1 in max list and index 1 in min list


big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]]

# add column to df_minmax

big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]] %>% mutate(threshold = ifelse(index %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1 ))

 ifelse(big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]]  %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1 )


mutate(big_list[["PMS_prox_idx_emp"]][["df_minmax"]][[1]], threshold = ifelse(~ .x %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1) )

ifelse(~ .x %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1)

big_list[["PMS_prox_idx_emp"]][["df_minmax"]][[1]] <- cbind(big_list[["PMS_prox_idx_emp"]][["df_minmax"]][[1]], 1:9)
```
```{r eval = F}
# removing minima that aren't above threshold
# add include row in df
big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]] <- big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[["PMS_prox_idx_transit"]][["maxmindiff"]] < 0.001), 0,1))

# plot w/ filter
big_list[["PMS_prox_idx_transit"]][["nopt"]] +geom_point(data = filter(big_list[["PMS_prox_idx_transit"]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```




## Childcare

Similarly to Pharmacies, Childcare has indiscernible maxima and minima in some areas, as seen in Figure 9. There is even such an area at the top of the largest peak. Figure 10 shows the difference again, and we can see that the same threshold of 0.001 may be appropriate. Figure 11 shows the density with the values with a difference beneath this threshold removed, showing 2 cutoffs for 3 groups. The second 'maxima' at the top of the peak was retained due the methodology. 

```{r fig.cap="density curve with minima and maxima"}
amen_num<- 3
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Healthcare

For Healthcare, a visual assessment of the density curve with the minima and maxima point doesn't reveal any point outside of expectation. The curve suggests 3 cutoff values, giving a total of 4 groups. 

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
threshold <- 0.001
amen_num = 4 
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Grocery

Grocery has a similar start to Pharmacies and Childcare. Removing the points below the same threshold suggests 2 cutoff points, giving 3 groups. Visually, there are plateau areas, similarly to other amenities, that may serve as decent additional cut off points.

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
amen_num = 5
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Primary Education

The final plot suggests 2 cutoff points, giving 3 groups.

```{r fig.cap="density curve with minima and maxima"}
amen_num<- 6
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
amen_num <- 6
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Secondary Education

For the first time, after removal of values below the threshold, only one cutoff point is suggested, giving two groups. 

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
amen_num = 7 
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Libraries

Not quite sure why the minima values aren't being plotted in the final plot for libraries only. For some reason there are sometimes two minima following each other, which is algebrically impossible. Will need to investigate. Regardless, the plot suggests 1 minima cutoff, giving 2 groups. 

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
amen_num = 8
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Parks

After removing values under the threshold, the curve suggests 2 cutoff locations, giving 3 groups.

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
amen_num = 9
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Transit

After removing all values below the same threshold of 0.001, Transit suggests one of the greatest number of groups: 5.

```{r fig.cap="density plot with suggested cutoff points in blue"}
# removing minima that aren't above threshold
# add include row in df
amen_num<- 10
threshold <- 0.001
big_list[[amen_num]][["df_minmax"]][[1]] <- big_list[[amen_num]][["df_minmax"]][[1]] %>% mutate(include = ifelse(index %in% which(big_list[[amen_num]][["maxmindiff"]] < threshold), 0,1))

# plot w/ filter
big_list[[amen_num]][["nopt"]] +geom_point(data = filter(big_list[[amen_num]][["df_minmax"]][[1]], include == 1), mapping = aes(x,y, col = type))+ theme(legend.position="none")
```

## Summary

(table with number of groups for each amenity)
```{r}
# remade this to have reproducible workflow instead of manual count
num_groups <- c(5,3,4,3,3,3,2,2,3,5)

cbind(amenities, num_groups)
```

# Next Steps
- Investigate 'weight' of distribution for every suggested groups
- Format table properly
- investigate change of bandwidth in kernel density


# Appendix: Extra Plots

## Healthcare

```{r fig.cap="density curve with minima and maxima"}
amen_num<- 4
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

## Grocery

```{r fig.cap="density curve with minima and maxima"}
amen_num<- 5
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

## Primary Education

```{r fig.cap="density curve with minima and maxima"}
amen_num<- 6
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

## Secondary Education

```{r fig.cap="density curve with minima and maxima"}
amen_num<- 7
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```


## Libraries

```{r fig.cap="density curve with minima and maxima"}
amen_num<- amen_num+1
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

## Parks
```{r fig.cap="density curve with minima and maxima"}
amen_num<- 9
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```

## Transit
```{r  fig.cap="density curve with minima and maxima"}
amen_num<- 10
# plot
big_list[[amen_num]][["plot"]]
#big_list[["PMS_prox_idx_emp"]][["nopt"]]
```

```{r fig.cap="difference between density value of a maxima-minima pairs, threshold = 0.001"}
plot(big_list[[amen_num]][["maxmindiff"]], ylab = "Difference", xlab= "")
abline(h = 0.001, lty=2, col = "grey")
```
